/**
 * @file top.v
 * 
 * This module implements all the modules of the RISC-V processor,
 * connecting the instruction memory, and data memory with the riscv_cpu module.
 * Also, it has a simple clock divider logic, to see the output of the cpu logic in 1Hz,
 * instead of the standard 100MHz generated by the FPGA.
 *
 * @input clk_in          Inputs clock signal.
 * @input reset           Inputs reset signal.
 * 
*/

module top (
    input clk_in, reset,
    output led1, led2, led3, led4, led5, led6, led7, led8
);
    // wire lines from other modules

    clock_divider_100M_to_1Hz slow_ass_bitch (clk_in, reset, clk);
    wire [31:0] PC;
    wire [31:0] Instr;
    wire MemWrite_rv32;
    wire [31:0] DataAdr_rv32, WriteData_rv32;
    wire [31:0] ReadData;
    // instantiate processor and memories
    riscv_cpu rvsingle (clk, reset, PC, Instr, MemWrite_rv32, DataAdr_rv32, WriteData_rv32, ReadData);
    instr_mem imem (PC, Instr);
    data_mem dmem (clk, MemWrite, DataAdr, WriteData, ReadData);

    assign {led1, led2, led3, led4, led5, led6, led7, led8} = WriteData_rv32;
    // output assignments
    
endmodule

module clock_divider_100M_to_1Hz (
    input wire clk_in,   // 100 MHz input clock
    input wire reset,        // Reset signal
    output reg clk       // 1 Hz output clock
);

    // Define the counter limit for 100MHz to 1Hz conversion
    localparam COUNTER_LIMIT = 100_000_000 / 2; // Divide by 2 for a full cycle

    reg [26:0] counter; // 27-bit counter (log2(50M) = 26.58)

    always @(posedge clk_in or posedge reset) begin
        if (reset) begin
            counter <= 0;
            clk <= 0;
        end else begin
            if (counter == COUNTER_LIMIT - 1) begin
                counter <= 0;
                clk <= ~clk; // Toggle the output clock
            end else begin
                counter <= counter + 1;
            end
        end
    end

endmodule


